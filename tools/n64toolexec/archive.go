// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"bytes"
	"errors"
	"fmt"
	"io"
	"os"
)

// Archive is an archive generated by go compile -pack, for details see
// go/src/cmd/internal/archive/archive.go
type Archive struct {
	f       *os.File
	Entries []Entry
}

type Entry struct {
	Name  string
	Mtime int64
	Uid   int
	Gid   int
	Mode  os.FileMode
	Data
}

type Data struct {
	Offset int64
	Size   int64
}

const (
	entryHeader     = "%-16s%-12d%-6d%-6d%-8o%-10d`\n"
	entryHeaderScan = "%16s%12d%6d%6d%8o%10d"
	entryLen        = 16 + 12 + 6 + 6 + 8 + 10 + 1 + 1
)

var (
	archiveHeader = []byte("!<arch>\n")
	archiveMagic  = []byte("`\n")

	errCorruptArchive = errors.New("corrupt archive")
	errNotObject      = errors.New("unrecognized object file format")
)

// ParseArchive parses an object file or archive from f.
func ParseArchive(f *os.File) (a *Archive, err error) {
	t := make([]byte, 8)
	_, err = io.ReadFull(f, t)
	if err != nil {
		if err == io.EOF {
			err = io.ErrUnexpectedEOF
		}
		return nil, err
	}

	if !bytes.Equal(t, archiveHeader) {
		return nil, errNotObject
	}

	a = &Archive{f: f}
	for {
		header := make([]byte, 60)
		_, err := io.ReadFull(a.f, header)
		if err == io.EOF {
			break
		} else if err != nil {
			return nil, err
		}

		if !bytes.Equal(header[58:60], archiveMagic) {
			return nil, errCorruptArchive
		}

		var (
			name     string
			mtime    int64
			uid, gid int
			mode     os.FileMode
			size     int64
		)
		_, err = fmt.Sscanf(string(header[:58]), entryHeaderScan, &name, &mtime, &uid, &gid, &mode, &size)
		if err != nil {
			return nil, err
		}

		fsize := size + size&1
		if fsize < 0 || fsize < size {
			return nil, errCorruptArchive
		}

		offset, _ := a.f.Seek(0, io.SeekCurrent)
		_, err = a.f.Seek(size, io.SeekCurrent)
		if err != nil {
			return nil, err
		}
		a.Entries = append(a.Entries, Entry{
			Name:  name,
			Mtime: mtime,
			Uid:   uid,
			Gid:   gid,
			Mode:  mode,
			Data:  Data{offset, size},
		})

		if size&1 != 0 {
			a.f.Seek(1, io.SeekCurrent)
		}
	}

	return a, nil
}

func (a *Archive) OpenEntry(name string) *io.SectionReader {
	for _, entry := range a.Entries {
		if entry.Name == name {
			return io.NewSectionReader(a.f, entry.Offset, entry.Size)
		}
	}
	return nil
}

// AddEntry adds an entry to the end of a, with the content from r.
func (a *Archive) AddEntry(name string, r io.ReadSeeker) error {
	off, _ := a.f.Seek(0, io.SeekEnd)
	size, _ := r.Seek(0, io.SeekEnd)
	r.Seek(0, io.SeekStart)

	n, err := fmt.Fprintf(a.f, entryHeader, TruncateToRune(name, 16), 0, 0, 0, 0, size)
	if err != nil || n != entryLen {
		fmt.Errorf("writing entry header: %w", err)
	}
	n1, _ := io.CopyN(a.f, r, size)
	if n1 != size {
		return err
	}
	if (off+size)&1 != 0 {
		a.f.Write([]byte{0}) // pad to even byte
	}
	a.Entries = append(a.Entries, Entry{
		Name: name,
		Data: Data{off + entryLen, size},
	})

	return nil
}

// TruncateToRune returns the longest prefix of s, up to a maximum length of n,
// terminating at the boundary after the last complete UTF-8 encoding that fits.
func TruncateToRune(s string, n int) string {
	t := ""
	for _, r := range s {
		if len(t+string(r)) > n {
			break
		}
		t += string(r)
	}
	return t
}
