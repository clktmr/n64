// Package fonts implements loading of fonts optimized for Nintendo 64.
//
// These fonts can be generated by [github.com/clktmr/n64/tools/mkfont].
package fonts

import (
	"image"

	"github.com/clktmr/n64/rcp/fixed"
	"github.com/embeddedgo/display/font/subfont"
)

// GlyphMap returns an image containing all glyphs of a [Subfont] and a rect
// describing subimage that represents the glyph. All images returned by
// GlyphMap are guaranteed to have the same format/type.
// This interface is an optimization for the [subfont.Data] interface. Subfonts
// can implement this for optimization, to avoid frequent changes in the RDP's
// texture image.
type GlyphMap interface {
	GlyphMap(r rune) (img image.Image, rect image.Rectangle, origin image.Point, advance int)
}

type Glyph struct {
	Origin  fixed.PointU8
	Rect    fixed.RectangleU8
	Advance fixed.UInt8
}

// Face is a [subfont.Face] which implements the [GlyphMap] optimization.
type Face struct {
	subfont.Face
}

// GlyphMap returns the image containing a glyph map with the specified rune.
// The subimage defined by rect contains the requested glyph, with it's origin
// and vertical advance in pixels.
//
//go:nosplit
func (f *Face) GlyphMap(r rune) (img image.Image, rect image.Rectangle, origin image.Point, advance int) {
	sf := getSubfont(f, r)
	if sf == nil {
		// try to use rune(0) to render unsupported codepoints
		r = 0
		sf = getSubfont(f, r)
		if sf == nil {
			return
		}
	}
	if sfd, ok := sf.Data.(*SubfontData); ok {
		return sfd.GlyphMap(int(r - sf.First))
	}
	img, origin, advance = sf.Data.Glyph(int(r - sf.First))
	rect = img.Bounds()
	return
}

//go:nosplit
func getSubfont(f *Face, r rune) (sf *subfont.Subfont) {
	// TODO: binary search
	for _, sf = range f.Subfonts {
		if sf != nil && sf.First <= r && r <= sf.Last {
			return sf
		}
	}
	if f.Loader == nil {
		return nil
	}
	sf, f.Subfonts = f.Loader.Load(r, f.Subfonts)
	return sf
}
